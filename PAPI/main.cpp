//  Created by 王方 on 05/12/2018.
//  Copyright © 2018 王方. All rights reserved.
//  This is example of using PAPI event for measureing performance

#include <stdio.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
#include <algorithm>
#include <queue>
#include "papi.h"
#include <string.h>
#include "tool.h"
#include <vector>
using namespace std;


bool Cmpare_R(const ResultArray &a, const ResultArray &b)
{
    return a.L2NormExact<b.L2NormExact;
}

void MinK(struct ObjectLowerBoundInCPU Obj[], int n, int k, struct ResultArray res[]);
double Exact_l2_comp(int Tag_No, double query_vector[], struct ObjectInDRAM objinmem[]);
ObjectLowerBoundInCPU *Reset_Lowerbound_Object(struct ObjectLowerBoundInCPU obj[]);
void from_SSD_to_Memory(struct ObjectInDRAM Object[], std::string const &filename);
void catch_querypoint(double query_point[][DIMENSION_NUM], std::string const &queryfile);
void knn_search(struct ResultArray res[], struct ObjectInDRAM Object[], double query[][DIMENSION_NUM]);

int main(int argc, char ** argv) {

    if(argc != 2){
        printf("Input data file path and query file path \n");
    }
    std::string datafile(argv[1]);
    std::string queryfile(argv[2]);
    //std::string  datafile("/home/csfwang/Desktop/ICDE2021/Data/imageNet_rand2340173.bin");
    //std::string  queryfile("/home/csfwang/Desktop/ICDE2021/Data/imageNet_rand200.bin");

    auto *Resultarray=new ResultArray[KNN_NUM];
    auto *Object = new ObjectInDRAM[DatasetVolume];
    double query[QUERY_NUM][DIMENSION_NUM];

    catch_querypoint(query, queryfile);
    from_SSD_to_Memory(Object, datafile);

    int retval, EventSet=PAPI_NULL, eventcode;
    long long int values[2];
    char eventname[PAPI_MAX_STR_LEN];
    retval = PAPI_library_init(PAPI_VER_CURRENT);
    if(retval != PAPI_VER_CURRENT){
        fprintf(stderr,"PAPI library init error!\n");
        exit(1);
    }
    if((retval = PAPI_create_eventset(&EventSet)) != PAPI_OK)
        fprintf(stderr,"PAPI create error %d: %s\n",retval,PAPI_strerror(retval));

    strcpy(eventname,"PAPI_L2_TCM");
    if((retval = PAPI_event_name_to_code(eventname,&eventcode)) != PAPI_OK)
        fprintf(stderr,"PAPI event code error 1 %d: %s\n",retval,PAPI_strerror(retval));
    if((retval = PAPI_add_event(EventSet,eventcode)) != PAPI_OK)
        fprintf(stderr,"PAPI event code error adding 1 %d: %s\n",retval,PAPI_strerror(retval));

    strcpy(eventname,"PAPI_L3_TCM");
    if((retval = PAPI_event_name_to_code(eventname,&eventcode)) != PAPI_OK)
        fprintf(stderr,"PAPI event code error 2 %d: %s\n",retval,PAPI_strerror(retval));
    if((retval = PAPI_add_event(EventSet,eventcode)) != PAPI_OK)
        fprintf(stderr,"PAPI event code error adding 2 %d: %s\n",retval,PAPI_strerror(retval));

    if((retval = PAPI_start(EventSet)) != PAPI_OK)
        fprintf(stderr,"PAPI start error %d: %s\n",retval,PAPI_strerror(retval));


    auto t1 = clock();
    knn_search(Resultarray, Object, query);
    auto totaltime = clock() - t1;

    if((retval = PAPI_stop(EventSet,values)) != PAPI_OK)
        fprintf(stderr,"PAPI stop error %d: %s\n",retval,PAPI_strerror(retval));
    fprintf(stdout,"After stopping the counters: C1 - %lld \n", values[0]);
    fprintf(stdout,"After stopping the counters: C2 - %lld \n", values[1]);

    if((retval = PAPI_cleanup_eventset(EventSet)) != PAPI_OK)
        fprintf(stderr,"PAPI cleanup error %d: %s\n",retval,PAPI_strerror(retval));
    if((retval = PAPI_destroy_eventset(&EventSet)) != PAPI_OK)
        fprintf(stderr,"PAPI destroy error %d: %s\n",retval,PAPI_strerror(retval));


    std::cout << "Per search time cost: " << totaltime/(CLOCKS_PER_SEC*1.0) <<" s \n";
    return 0;
}


void knn_search(struct ResultArray res[], struct ObjectInDRAM Object[], double query[][DIMENSION_NUM]){
    for(int z = 0; z<QUERY_NUM; z++){
        for(int j = 0; j < KNN_NUM; j++){
            int temp_tagno = res[j].TagNO;
            res[j].L2NormExact = Exact_l2_comp(temp_tagno, query[z], Object);
        }
        sort(res, res + KNN_NUM, Cmpare_R);
        for(int no = 0; no < DatasetVolume; no++){
            double lb= 0.0;
            for(int i=0; i < DIMENSION_NUM; i++){
                double tem = (Object[no].Value[i] - query[z][i]);
                lb += tem * tem ;
            }
            if(res[KNN_NUM-1].L2NormExact >= lb){
                double temp_exact = Exact_l2_comp(no, query[z], Object);
                if (res[KNN_NUM - 1].L2NormExact >= temp_exact) {
                    res[KNN_NUM - 1].L2NormExact = temp_exact;
                    res[KNN_NUM - 1].TagNO = no;
                    sort(res, res + KNN_NUM, Cmpare_R);
                }
            }
        }
    }
}

void MinK(struct ObjectLowerBoundInCPU Obj[], int n, int k, struct ResultArray res[]){
    priority_queue <ObjectLowerBoundInCPU, vector<ObjectLowerBoundInCPU>,cmplb> pq;
    for(int i = 0;i < k;i++)
        pq.push(Obj[i]);
    for(int i = k;i < n;i++)
        if(Obj[i].Lowerbound <pq.top().Lowerbound){
            pq.pop();
            pq.push(Obj[i]);
        }
    for(int i = 0; i < k;i++){
        res[k-1-i].L2NormExact = pq.top().Lowerbound;
        res[k-1-i].TagNO = pq.top().TagNO;
        pq.pop();
    }
}


void from_SSD_to_Memory(struct ObjectInDRAM Object[], std::string const &filename){

    auto *ff =new double[DatasetVolume * DIMENSION_NUM];
    std::ifstream ifs(filename, std::ios::binary | std::ios::in);
    ifs.read((char*)ff, sizeof(double) * DatasetVolume * DIMENSION_NUM);
    ifs.close();

    for(int i = 0; i < DatasetVolume; i++)
        for(int j = 0; j < DIMENSION_NUM; j++)
            Object[i].Value[j] = ff[i * DIMENSION_NUM + j];

    printf("Load Dataset Done.\n");
    delete[] ff;
    return;
}

void catch_querypoint(double query_point[][DIMENSION_NUM], std::string const &queryfile){

     double *ff = new double[DIMENSION_NUM * QUERY_NUM];
    std::ifstream ifs(queryfile, std::ios::binary | std::ios::in);
    ifs.read((char*)ff, sizeof(double) * QUERY_NUM * DIMENSION_NUM);
    ifs.close();
    for(int i = 0; i < QUERY_NUM; i++ )
        for (int j = 0; j < DIMENSION_NUM; j++)
            query_point[i][j] = ff[i * DIMENSION_NUM + j];

    delete[] ff;
    return;
}

double Exact_l2_comp(int Tag_No, double query_vector[], struct ObjectInDRAM objinmem[]){
    //Read Object
    double l2_dist=0;
    for(int i=0;i<DIMENSION_NUM;i++)
    {
        l2_dist+=SQUARE(query_vector[i] -objinmem[Tag_No].Value[i] );
    }
    return l2_dist;
}

double reportCost(struct timeval begin, struct timeval finish)
{
    return 1.0*((finish.tv_sec*1000000L+finish.tv_usec) - (begin.tv_sec*1000000L+begin.tv_usec))/1000000L;
}
